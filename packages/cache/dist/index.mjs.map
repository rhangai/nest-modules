{"version":3,"sources":["../src/cache.ts","../src/cache-options.ts","../src/cache-decorator.ts"],"sourcesContent":["import Heap from 'heap';\nimport {\n\tcacheOptionsNormalize,\n\ttype CacheOptions,\n\ttype CacheOptionsNormalized,\n} from './cache-options';\n\ntype CacheEntryPending<TValue> = {\n\tvalue: Promise<TValue>;\n\tcreatedAt: number;\n};\n\ntype CacheEntry<TKey, TValue> = {\n\tkey: TKey;\n\t/**\n\t * The promise result\n\t */\n\tvaluePromise: Promise<TValue>;\n\t/**\n\t * If the entry is still valid\n\t */\n\tinvalid: boolean;\n\t/**\n\t * When this entry was created\n\t */\n\tcreatedAt: number;\n\t/**\n\t * Value for pending action\n\t */\n\tpending: CacheEntryPending<TValue> | null;\n};\n\n/// Type for the function\ntype CacheFn<TKey, TValue> = (key: TKey) => TValue | Promise<TValue>;\n\n/**\n * Async cache with better timing functions\n */\nexport class Cache<TKey = string | number, TValue = unknown> {\n\t/**\n\t * The entry map\n\t */\n\tprivate readonly cacheEntryMap = new Map<TKey, CacheEntry<TKey, TValue>>();\n\n\t/**\n\t * The entry heap. Used to keep a sorted list of cache entries based on creation time.\n\t */\n\tprivate readonly cacheEntryHeap = new Heap<CacheEntry<TKey, TValue>>((a, b) => {\n\t\tif (a.invalid) {\n\t\t\tif (b.invalid) return 0;\n\t\t\treturn -1;\n\t\t} else if (b.invalid) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn a.createdAt - b.createdAt;\n\t});\n\n\t/**\n\t * Cache options\n\t */\n\tprivate readonly options: CacheOptionsNormalized;\n\n\t/**\n\t * Construct the cache\n\t */\n\tconstructor(options?: CacheOptions | number | undefined) {\n\t\tthis.options = cacheOptionsNormalize(options);\n\t}\n\n\t/**\n\t * Get a cached value, if possible.\n\t * Otherwise, it saves the entry in the cache.\n\t *\n\t * If the entry is cold while being fetched, it will become hot again\n\t */\n\tget(key: TKey, lazyFn: CacheFn<TKey, TValue>): Promise<TValue> {\n\t\tconst oldEntry = this.cacheEntryMap.get(key);\n\n\t\tconst now = Date.now();\n\n\t\tlet entry = oldEntry;\n\t\tif (!entry || !this.isEntryValid(entry, now)) {\n\t\t\tentry = this.refreshEntry(oldEntry, key, lazyFn, now);\n\t\t} else if (this.isEntryCold(entry, now)) {\n\t\t\tthis.refreshEntryCold(entry, lazyFn, now);\n\t\t}\n\t\treturn entry.valuePromise;\n\t}\n\n\t/**\n\t * Deletes an item from the cache\n\t */\n\tdelete(key: TKey): void {\n\t\tconst entry = this.cacheEntryMap.get(key);\n\t\tif (entry) {\n\t\t\tentry.invalid = true;\n\t\t\tthis.cacheEntryMap.delete(key);\n\t\t\tthis.cacheEntryHeap.updateItem(entry);\n\t\t\tthis.refreshEntryHeap(Date.now());\n\t\t}\n\t}\n\n\t/**\n\t * Refreshes the cache. Cleaning every expired item.\n\t */\n\trefresh(): void {\n\t\tthis.refreshEntryHeap(Date.now());\n\t}\n\n\t/**\n\t * Clears the cache\n\t */\n\tclear(): void {\n\t\tthis.cacheEntryHeap.clear();\n\t\tthis.cacheEntryMap.clear();\n\t}\n\n\t/**\n\t * Size of the cache\n\t */\n\tsize(): number {\n\t\treturn this.cacheEntryHeap.size();\n\t}\n\n\t/**\n\t * Check if the cache has the entry (But does not refresh it)\n\t */\n\thasEntry(key: TKey): boolean {\n\t\treturn this.cacheEntryMap.has(key);\n\t}\n\n\t/**\n\t * Check if the entry is still valid\n\t */\n\tprivate isEntryValid(entry: CacheEntry<TKey, TValue>, now: number): boolean {\n\t\tif (entry.invalid) return false;\n\t\tif (this.isTimeExpired(entry.createdAt, now)) return false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check if the entry is still valid\n\t */\n\tprivate isTimeExpired(time: number, now: number): boolean {\n\t\tconst expiration = time + this.options.duration;\n\t\treturn now >= expiration;\n\t}\n\n\t/**\n\t * Check if entry is already cold\n\t */\n\tprivate isEntryCold(entry: CacheEntry<TKey, TValue>, now: number): boolean {\n\t\tconst coldTime = entry.createdAt + this.options.durationUntilCold;\n\t\tif (now >= coldTime) return true;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Faz o refresh de uma entrada no cache\n\t */\n\tprivate refreshEntry(\n\t\toldEntry: CacheEntry<TKey, TValue> | undefined,\n\t\tkey: TKey,\n\t\tlazyFn: CacheFn<TKey, TValue>,\n\t\tnow: number,\n\t): CacheEntry<TKey, TValue> {\n\t\tif (oldEntry) {\n\t\t\tconst entry = oldEntry;\n\t\t\t// If there is a valid pending entry\n\t\t\tif (oldEntry.pending && !this.isTimeExpired(oldEntry.pending.createdAt, now)) {\n\t\t\t\tentry.createdAt = oldEntry.pending.createdAt;\n\t\t\t\tentry.valuePromise = oldEntry.pending.value.catch((err) => {\n\t\t\t\t\tentry.invalid = true;\n\t\t\t\t\tthrow err;\n\t\t\t\t});\n\t\t\t\tentry.pending = null;\n\n\t\t\t\t// Check if the pending entry is already cold\n\t\t\t\tif (this.isEntryCold(entry, now)) {\n\t\t\t\t\tthis.refreshEntryCold(entry, lazyFn, now);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Fresh new entry\n\t\t\t\tentry.pending = null;\n\t\t\t\tentry.createdAt = now;\n\t\t\t\tentry.valuePromise = Promise.resolve(lazyFn(key)).catch((err) => {\n\t\t\t\t\tentry.invalid = true;\n\t\t\t\t\tthrow err;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Refresh the entries\n\t\t\tentry.invalid = false;\n\t\t\tthis.cacheEntryHeap.updateItem(entry);\n\t\t\tthis.refreshEntryHeap(now);\n\t\t\treturn entry;\n\t\t}\n\n\t\ttype Entry = Omit<CacheEntry<TKey, TValue>, 'valuePromise'> & {\n\t\t\tvaluePromise?: Promise<TValue>;\n\t\t};\n\t\tconst entry: Entry = {\n\t\t\tkey,\n\t\t\tinvalid: false,\n\t\t\tpending: null,\n\t\t\tcreatedAt: Date.now(),\n\t\t};\n\t\tentry.valuePromise = Promise.resolve(lazyFn(key)).catch((err) => {\n\t\t\tentry.invalid = true;\n\t\t\tthrow err;\n\t\t});\n\t\tconst result = entry as CacheEntry<TKey, TValue>;\n\t\tthis.cacheEntryMap.set(key, result);\n\t\tthis.cacheEntryHeap.push(result);\n\t\tthis.refreshEntryHeap(now);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Faz o refresh de uma entrada no cache\n\t */\n\tprivate refreshEntryCold(\n\t\tentryParam: CacheEntry<TKey, TValue>,\n\t\tlazyFn: CacheFn<TKey, TValue>,\n\t\tnow: number,\n\t) {\n\t\tconst entry = entryParam;\n\t\tif (!entry.pending) {\n\t\t\tconst valuePromise = Promise.resolve(lazyFn(entry.key)).then(\n\t\t\t\t(newValue) => {\n\t\t\t\t\tif (entry.createdAt < now) {\n\t\t\t\t\t\tentry.invalid = false;\n\t\t\t\t\t\tentry.createdAt = now;\n\t\t\t\t\t\tentry.valuePromise = Promise.resolve(newValue);\n\t\t\t\t\t\tentry.pending = null;\n\t\t\t\t\t\tthis.cacheEntryHeap.updateItem(entry);\n\t\t\t\t\t\tthis.refresh();\n\t\t\t\t\t}\n\t\t\t\t\treturn newValue;\n\t\t\t\t},\n\t\t\t\t(err) => {\n\t\t\t\t\tentry.pending = null;\n\t\t\t\t\tthrow err;\n\t\t\t\t},\n\t\t\t);\n\t\t\tentry.pending = {\n\t\t\t\tvalue: valuePromise,\n\t\t\t\tcreatedAt: now,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Faz o refresh de uma entrada no cache\n\t */\n\tprivate refreshEntryHeap(now: number) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, no-constant-condition\n\t\twhile (true) {\n\t\t\tconst top = this.cacheEntryHeap.peek();\n\t\t\tif (!top || this.isEntryValid(top, now)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.cacheEntryHeap.pop();\n\t\t\tthis.cacheEntryMap.delete(top.key);\n\t\t}\n\t}\n}\n","export type CacheOptions = {\n\t/**\n\t * Duration for cache\n\t */\n\tduration?: number;\n\t/**\n\t * Duration for cache until it becomes cold. Must be less than duration otherwise\n\t * it wont do anything. Defaults to (2/3) of the duration\n\t */\n\tdurationUntilCold?: number;\n};\n\nexport type CacheOptionsNormalized = {\n\tduration: number;\n\tdurationUntilCold: number;\n};\n\n// Default duration when using cache (30s)\nconst DEFAULT_DURATION = 30000;\n\n/**\n * Normalize the cache options\n */\nexport function cacheOptionsNormalize(\n\toptionsParam: CacheOptions | number | undefined\n): CacheOptionsNormalized {\n\tlet options: CacheOptions;\n\tif (typeof optionsParam === 'number') {\n\t\toptions = { duration: optionsParam };\n\t} else {\n\t\toptions = optionsParam ?? {};\n\t}\n\tconst duration = options.duration ?? DEFAULT_DURATION;\n\treturn {\n\t\tduration,\n\t\tdurationUntilCold: options.durationUntilCold ?? Math.round((duration * 2) / 3),\n\t};\n}\n","import { Cache } from './cache';\nimport type { CacheOptions } from './cache-options';\n\n/**\n * Cache decorator\n *\n * Applys the cache using the given decorator\n */\nexport function CacheDecorator<TCacheKey>(\n\tkeyFn: (...params: any[]) => TCacheKey,\n\tcacheOptions?: CacheOptions | number\n): MethodDecorator {\n\treturn (target, propertyKey, descriptor: any) => {\n\t\tif (descriptor.value != null) {\n\t\t\tconst originalFn = descriptor.value;\n\t\t\tif (typeof originalFn !== 'function') {\n\t\t\t\tthrow new Error(`Must only decorate functions`);\n\t\t\t}\n\t\t\tconst cache = new Cache<TCacheKey, any>(cacheOptions);\n\t\t\t// eslint-disable-next-line func-names\n\t\t\tconst newValue = function (this: any, ...params: any[]) {\n\t\t\t\tconst cacheKey = keyFn(...params);\n\t\t\t\treturn cache.get(cacheKey, () => originalFn.apply(this, params));\n\t\t\t};\n\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\tdescriptor.value = newValue;\n\t\t} else {\n\t\t\tthrow new Error(`CacheDecorator can only be used on functions`);\n\t\t}\n\t};\n}\n"],"mappings":"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","names":["entry"]}